import { TraitState } from '@angular/compiler-cli/src/ngtsc/transform';
var handlerName = {
    'NgModule': 'NgModuleDecoratorHandler',
    'Pipe': 'PipeDecoratorHandler',
    'Injectable': 'InjectableDecoratorHandler',
    'Directive': 'DirectiveDecoratorHandler',
    'Component': 'ComponentDecoratorHandler'
};
export var filterByHandler = function (annotation) { return function (trait) {
    return trait.handler.name === handlerName[annotation];
}; };
export var isAnalysed = function (trait) {
    return (trait === null || trait === void 0 ? void 0 : trait.state) === TraitState.Analyzed || (trait === null || trait === void 0 ? void 0 : trait.state) === TraitState.Resolved;
};
var Symbol = /** @class */ (function () {
    function Symbol(workspace, node) {
        this.workspace = workspace;
        this.node = node;
    }
    Object.defineProperty(Symbol.prototype, "name", {
        /** Name of the class */
        get: function () {
            return this.node.name.getText();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Symbol.prototype, "path", {
        /** Path where the class is declared */
        get: function () {
            if (!this._path) {
                this._path = this.node.getSourceFile().fileName;
            }
            return this._path;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Symbol.prototype, "diagnostics", {
        /** Logs from @angular/compiler when something got wrong */
        get: function () {
            var _a;
            return ((_a = this.trait) === null || _a === void 0 ? void 0 : _a.state) === TraitState.Analyzed ? this.trait.analysisDiagnostics : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Symbol.prototype, "isAnalysed", {
        /** Check if the ClassDeclaration has been analyzed by the trait compiler */
        get: function () {
            return isAnalysed(this.trait);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Symbol.prototype, "record", {
        /** The record of the ClassDeclaration in the trait compiler */
        get: function () {
            return this.workspace.traitCompiler.recordFor(this.node);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Symbol.prototype, "analysis", {
        /** The result of the analysis. Specific per annotation */
        get: function () {
            var _a;
            this.ensureAnalysis();
            if (((_a = this.trait) === null || _a === void 0 ? void 0 : _a.state) === TraitState.Analyzed) {
                var message = "An error occurred during analysis of \"" + this.name + "\": ";
                var error = this.diagnostics;
                throw new Error(message + error);
            }
            // As we analyzed the node above it should be ok...
            if (isAnalysed(this.trait)) {
                return this.trait.analysis;
            }
            else {
                throw new Error("Analysis for node " + this.name + " couldn't be completed");
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Symbol.prototype, "trait", {
        get: function () {
            var _a;
            if (!this._trait) {
                this._trait = (_a = this.record) === null || _a === void 0 ? void 0 : _a.traits.find(filterByHandler(this.annotation));
            }
            return this._trait;
        },
        enumerable: false,
        configurable: true
    });
    /** Analyse this specific ClassDeclaration */
    Symbol.prototype.analyse = function () {
        this.workspace.traitCompiler.analyzeNode(this.node);
        this.workspace.traitCompiler.resolveNode(this.node);
        // @question should we record NgModule Scope dependencies here ???
    };
    Symbol.prototype.ensureAnalysis = function () {
        if (!this.record) {
            this.analyse();
        }
    };
    return Symbol;
}());
export { Symbol };
//# sourceMappingURL=symbol.js.map